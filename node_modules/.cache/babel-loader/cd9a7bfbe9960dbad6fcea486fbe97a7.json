{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/ashnove/Documents/PROJECT MATERIALS/PathFinding Demo/route-finder/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _classCallCheck from\"/home/ashnove/Documents/PROJECT MATERIALS/PathFinding Demo/route-finder/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import PriorityQueue from\"priorityqueue\";var Pair=function Pair(dis,cell){_classCallCheck(this,Pair);this.cell=cell;this.dis=dis;};var comparator=function comparator(nodeA,nodeB){var a=nodeA.dis;var b=nodeB.dis;return a<b?1:a>b?-1:0;};export function dijkstra(grid,start,end){var visitedNodesInOrder=[];start.distance=0;var pq=new PriorityQueue({comparator:comparator});pq.push(new Pair(0,start));while(pq.isEmpty()===false){var from=pq.top().cell;var pq_dis=pq.top().dis;pq.pop();if(pq_dis>from.distance)continue;if(from.isWall)continue;if(from===end)return visitedNodesInOrder;var children=getChildren(from,grid);console.log(from);visitedNodesInOrder.push(from);var _iterator=_createForOfIteratorHelper(children),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var to=_step.value;if(pq_dis+1<to.distance){to.distance=from.distance+1;to.previousNode=from;pq.push(new Pair(to.distance,to));console.log(pq);}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}return visitedNodesInOrder;}export function getShortestPath(end){var path=[];var curr=end;while(curr!==null){path.unshift(curr);curr=curr.previousNode;}return path;}function getChildren(node,grid){var children=[];var col=node.col,row=node.row;if(row<grid.length-1)children.push(grid[row+1][col]);if(row>0)children.push(grid[row-1][col]);if(col<grid[0].length-1)children.push(grid[row][col+1]);if(col>0)children.push(grid[row][col-1]);return children;}","map":{"version":3,"sources":["/home/ashnove/Documents/PROJECT MATERIALS/PathFinding Demo/route-finder/src/simulator/Algorithms/dikjstra.js"],"names":["PriorityQueue","Pair","dis","cell","comparator","nodeA","nodeB","a","b","dijkstra","grid","start","end","visitedNodesInOrder","distance","pq","push","isEmpty","from","top","pq_dis","pop","isWall","children","getChildren","console","log","to","previousNode","getShortestPath","path","curr","unshift","node","col","row","length"],"mappings":"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","sourcesContent":["import PriorityQueue from \"priorityqueue\";\n\nclass Pair {\n    constructor(dis, cell){\n        this.cell = cell;\n        this.dis = dis;\n    }\n}\nconst comparator = (nodeA, nodeB) => {\n    const a = nodeA.dis;\n    const b = nodeB.dis;\n    return (a < b ? 1 : a > b ? -1 : 0);    \n}\nexport function dijkstra(grid, start, end) {\n    const visitedNodesInOrder = [];\n    start.distance = 0;\n    \n    const pq = new PriorityQueue({comparator});\n    pq.push(new Pair(0, start));\n    while (pq.isEmpty() === false) {\n        \n        const from = pq.top().cell;\n        const pq_dis = pq.top().dis;\n        pq.pop();\n      \n        if(pq_dis > from.distance) continue;\n        if (from.isWall) continue;\n        if (from === end) return visitedNodesInOrder;\n        const children = getChildren(from, grid);\n        \n        console.log(from);\n        visitedNodesInOrder.push(from);\n        for (const to of children) {\n            if( pq_dis + 1  < to.distance ){\n                to.distance = from.distance + 1;\n                to.previousNode = from;\n                pq.push(new Pair(to.distance, to));\n                console.log(pq);\n                }\n        }\n    }\n    return visitedNodesInOrder;\n}\nexport function getShortestPath(end) {\n    const path = [];\n    let curr = end;\n    while (curr !== null) {\n      path.unshift(curr);\n      curr = curr.previousNode;\n    }\n    return path;\n}\nfunction getChildren(node, grid) {\n    const children = [];\n    const {col, row} = node;\n    if (row < grid.length - 1) children.push(grid[row + 1][col]);\n    if (row > 0) children.push(grid[row - 1][col]);\n    if (col < grid[0].length - 1) children.push(grid[row][col + 1]);\n    if (col > 0) children.push(grid[row][col - 1]);\n    return children;\n}\n  "]},"metadata":{},"sourceType":"module"}